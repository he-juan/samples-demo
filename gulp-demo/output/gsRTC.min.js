function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

Record.prototype.openAudio = function (data) {
    var This = this;
    console.info("share audio: " + JSON.stringify(data, null, '    '));
    if (!data || !data.type) {
        console.warn('share audio: invalid parameters! ');
        data && data.callback && data.callback({ codeType: This.CODE_TYPE.PARAMETER_ERROR });
        return;
    }

    var type = 'audio';

    var stream = This.getStream(type, true);
    if (stream) {
        This.closeStream(stream);
    }
    var audioRefreshResult = function audioRefreshResult(event) {
        console.info('audio refresh result: ' + JSON.stringify(event, null, '    '));
        if (event.codeType === 999) {
            console.info('shareAudio result success');
        } else {
            console.warn('shareAudio result failed');
        }
        data.callback && data.callback({ codeType: event.codeType, stream: event.stream });
    };

    var getMediaCallBack = function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(args) {
            return regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                    switch (_context.prev = _context.next) {
                        case 0:
                            if (args.stream) {
                                console.info('get stream: ' + args.stream ? args.stream.id : null);
                                // This.processAddStream(stream, session.pc, type)
                                This.setStream(args.stream, type, true);
                                audioRefreshResult({ codeType: This.CODE_TYPE.ACTION_SUCCESS, stream: args.stream });
                            } else if (args.error) {
                                console.warn('Get audio stream failed: ' + args.error);
                                audioRefreshResult({ codeType: This.prototype.getGumErrorCode('audio', args.error.name) });
                            }

                        case 1:
                        case 'end':
                            return _context.stop();
                    }
                }
            }, _callee, this);
        }));

        return function getMediaCallBack(_x) {
            return _ref.apply(this, arguments);
        };
    }();

    if (stream) {
        console.warn("暂时不会出现");
        // This.streamMuteSwitch({stream: stream, type: type, mute: false})
        // audioRefreshResult({codeType: This.CODE_TYPE.ACTION_SUCCESS})
    } else {
        console.info('getting new stream');
        This.getStreamFromDevice({ streamType: 'audio', constraints: data.constraints, callback: getMediaCallBack });
    }
};

Record.prototype.switchLocalAudioDevice = function (data) {
    console.info('switch audio device: ' + JSON.stringify(data, null, '    '));
    var This = this;
    if (!data || !data.constraints || !data.constraints.audio || !data.constraints.audio.deviceId) {
        console.warn('deviceId mandatory');
        This.trigger('onError', { codeType: This.CODE_TYPE.PARAMETER_ERROR });
        return;
    }

    var type = 'audio';

    var switchAudioSourceResult = function switchAudioSourceResult(event) {
        console.info('switch audio result ' + JSON.stringify(event, null, '    '));
        if (event.codeType === 999) {
            console.info('switch audio result success');
        } else {
            console.warn('switch audio result failed');
        }
        data.callback && data.callback({ codeType: event.codeType, stream: event.stream });
    };
    // For firefox, delete the previous stream first, and then get stream again according to the device
    // bug error: Concurrent mic process limit
    var preStream = This.getStream(type, true);
    if (preStream) {
        This.closeStream(preStream);
    }

    function getMediaCallBack(event) {
        if (event.stream) {
            var stream = event.stream;
            if (This.isMute) {
                This.streamMuteSwitch({ stream: stream, type: 'audio', mute: true });
            }
            This.setStream(stream, type, true);
            switchAudioSourceResult({ codeType: This.CODE_TYPE.ACTION_SUCCESS, stream: stream });
        } else {
            console.info('switch Local audio Device get stream failed', event.error);
            switchAudioSourceResult({ codeType: 201 });
        }
    }
    var parameters = { streamType: 'audio', constraints: data.constraints, callback: getMediaCallBack };
    This.getStreamFromDevice(parameters);
};

Record.prototype.stopAudio = function (data) {
    var This = this;
    console.info("stopShareAudio: " + JSON.stringify(data, null, '    '));
    if (!data) {
        console.warn('stopShareAudio: invalid parameters! ');
        data && data.callback && data.callback({ codeType: This.CODE_TYPE.PARAMETER_ERROR });
        return;
    }

    var stopShareAudioCallBack = function stopShareAudioCallBack(event) {
        console.info('stop share audio data: ' + JSON.stringify(event, null, '    '));
        if (event.codeType === 999) {
            This.localStreams.audio = null;
            console.info('stop share audio success');
        } else {
            console.warn('stop share audio failed');
        }
        data.callback && data.callback({ codeType: event.codeType });
    };

    var stream = This.getStream('audio', true);
    if (stream) {
        This.closeStream(stream);
        // This.streamMuteSwitch({stream: stream, type: 'audio', mute: true})
        stopShareAudioCallBack({ codeType: This.CODE_TYPE.ACTION_SUCCESS });
    } else {
        console.warn('audio stream is null');
        stopShareAudioCallBack({ codeType: This.CODE_TYPE.FAILED_TO_MUTE_MIC });
    }
};

Record.prototype.openVideo = function (data) {
    var This = this;
    console.info('open local video camera: ' + JSON.stringify(data, null, '    '));
    if (!data || !data.callback) {
        console.warn('shareVideo: invalid parameters');
        data && data.callback && data.callback({ codeType: This.CODE_TYPE.PARAMETER_ERROR });
        return;
    }

    var type = 'main';
    var getStreamCount = 0;
    var videoStream = void 0;

    function videoOnResult(event) {
        console.info('video on result, isLocalVideoOn' /*+ session.isLocalVideoOn*/);
        if (event.codeType === 999 /*&& session.isLocalVideoOn || (session.isGDS && session.isGDSVideoReqSucceeded)*/) {
                console.info('video on success');
                This.videoUpResolution = data.constraints.video;
            } else {
            event.codeType = /*session.errorCode ||*/This.CODE_TYPE.FAILED_TO_VIDEO_ON;
            console.warn('video on failed, code ' + event.codeType);
            var stream = This.getStream(type, true);
            This.closeStream(stream);
        }
        data && data.callback({ codeType: event.codeType, stream: videoStream, type: type });
    }

    function getMediaCallBack(event) {
        if (event.stream) {
            console.info('get stream success ' + event.stream.id);
            videoStream = event.stream;
            var video = document.createElement('video');
            video.srcObject = videoStream;
            video.onloadedmetadata = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
                var constraints, previousStream;
                return regeneratorRuntime.wrap(function _callee2$(_context2) {
                    while (1) {
                        switch (_context2.prev = _context2.next) {
                            case 0:
                                console.info("video: " + video.videoWidth + " * " + video.videoHeight);
                                constraints = {
                                    video: {
                                        width: video.videoWidth,
                                        height: video.videoHeight
                                    }
                                };
                                previousStream = This.getStream(type, true);

                                if (previousStream) {
                                    console.info('clear previous stream');
                                    This.closeStream(previousStream);
                                }
                                This.setVideoUpResolution(constraints);

                                This.setStream(videoStream, type, true);
                                This.action = 'shareVideo';
                                videoOnResult({ codeType: 999, stream: videoStream });

                            case 8:
                            case 'end':
                                return _context2.stop();
                        }
                    }
                }, _callee2, this);
            }));
        } else {
            console.info('get stream failed');
            parameters.error = event.error;
            parameters.isFirefox = Record.prototype.getBrowserDetail().browser === 'firefox';
            getStreamCount++;
            if (event.constraints && (event.error.name === 'OverconstrainedError' || event.error.name === 'ConstraintNotSatisfiedError') && getStreamCount < 5) {
                var constraints = void 0;
                if (getStreamCount < 2) {
                    constraints = This.setConstraintsOfGetStream(parameters, event.constraints);
                } else {
                    data.action = 'switchLocalVideoDevice';
                    constraints = This.setConstraintsOfGetStream(parameters, event.constraints);
                }
                This.getMedia(parameters, constraints);
            } else {
                data.callback && data.callback({
                    codeType: Record.prototype.getGumErrorCode('video', event.error.name)
                });
            }
        }
    }

    var parameters = {
        streamType: 'video',
        constraints: data.constraints,
        callback: getMediaCallBack
    };

    This.getStreamFromDevice(parameters);
};

Record.prototype.switchLocalVideoDevice = function (data) {
    console.info('switch Local video Device: ' + JSON.stringify(data, null, '   '));
    var This = this;
    if (!data || !data.constraints || !data.constraints.video || !data.constraints.video.deviceId) {
        console.warn('switchLocalVideoDevice: invalid parameters');
        data && data.callback && data.callback({ codeType: This.CODE_TYPE.PARAMETER_ERROR });
        return;
    }
    var getStreamCount = 0;

    var switchVideoCallback = function switchVideoCallback(evt) {
        console.info('switch video callback data: ' + JSON.stringify(evt, null, '    '));
        if (evt.codeType === 999) {
            console.info('video switch success');
            This.setVideoUpResolution(evt.constraints);
            This.videoUpResolution = data.constraints.video;
        } else {
            console.info('video switch failed');
        }
        data.callback && data.callback({ codeType: evt.codeType, stream: evt.stream });
    };

    var getMediaCallBack = function () {
        var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(event) {
            var type, preVideoStream, stream, versionInfo, constraints;
            return regeneratorRuntime.wrap(function _callee3$(_context3) {
                while (1) {
                    switch (_context3.prev = _context3.next) {
                        case 0:
                            if (event.stream) {
                                console.info('get stream success');
                                type = 'main';
                                preVideoStream = This.getStream(type, true);

                                if (preVideoStream) {
                                    console.info('clear before video stream: ' + preVideoStream.id);
                                    This.closeStream(preVideoStream);
                                }

                                stream = event.stream;

                                This.setStream(stream, type, true);
                                switchVideoCallback({ codeType: This.CODE_TYPE.ACTION_SUCCESS, constraints: event.constraints, stream: stream });
                            } else {
                                console.info('switch Local video Device get stream failed');
                                parameters.error = event.error;
                                versionInfo = This.getBrowserDetail();

                                parameters.isFirefox = versionInfo.browser === 'firefox';
                                parameters.action = 'switchLocalVideoDevice';
                                getStreamCount++;
                                if (event.constraints && (event.error.name === 'OverconstrainedError' || event.error.name === 'ConstraintNotSatisfiedError' || event.error.name === 'Error' && versionInfo.browser === 'safari' && versionInfo.UIVersion == '12.1.2') && getStreamCount < 2) {
                                    constraints = This.setConstraintsOfGetStream(parameters, event.constraints);

                                    This.getMedia(parameters, constraints);
                                } else {
                                    switchVideoCallback({ codeType: 201 });
                                }
                            }

                        case 1:
                        case 'end':
                            return _context3.stop();
                    }
                }
            }, _callee3, this);
        }));

        return function getMediaCallBack(_x2) {
            return _ref3.apply(this, arguments);
        };
    }();

    var parameters = {
        streamType: 'video',
        constraints: data.constraints,
        callback: getMediaCallBack
    };
    This.getStreamFromDevice(parameters);
};

Record.prototype.stopVideo = function (data) {
    var This = this;
    console.info('stop share Local video: ' + JSON.stringify(data, null, '    '));
    if (!data) {
        console.info('invalid parameters!');
        data && data.callback && data.callback({ codeType: This.CODE_TYPE.PARAMETER_ERROR });
        return;
    }

    var stopVideoCallback = function stopVideoCallback(event) {
        console.info('video off result data: ' + JSON.stringify(event, null, '    '));
        if (event.codeType === 999) {
            This.localStreams.main = null;
            console.info('video off success');
        } else {
            console.warn('video off failed, code ' + event.codeType);
        }

        data.callback && data.callback({ codeType: event.codeType });
    };

    var type = 'main';
    This.action = 'stopVideo';

    var stream = This.getStream(type, true);
    if (stream) {
        This.closeStream(stream);
        This.setStream(null, type, true);
        stopVideoCallback({ codeType: 999 });
    } else {
        console.warn('stopShareVideo: video stream is null ');
    }
};

Record.prototype.openShare = function (data) {
    var This = this;
    console.info('share screen');
    if (!data || !data.constraints || !data.constraints.video) {
        console.info('invalid parameters to screen share: ' + JSON.stringify(data, null, '    '));
        data && data.callback && data.callback({ codeType: This.CODE_TYPE.PARAMETER_ERROR });
        return;
    }

    var type = 'slides';
    function getMediaCallBack(event) {
        if (event.stream) {
            console.info('get stream success, ' + event.stream.id);
            var stream = event.stream;
            var mixStream = void 0;
            if (This.getBrowserDetail().browser === 'firefox') {
                var tracks = stream.getVideoTracks();
                tracks[0].onended = function () {
                    stopCategory({ type: 'slides' });
                };
            } else {
                stream.oninactive = function () {
                    console.warn('user clicks the bottom share bar to stop sharing');
                    stopCategory({ type: 'slides' });
                };
            }

            var localAudioStream = This.getStream('audio', true);
            if (localAudioStream && stream.getAudioTracks().length > 0) {
                mixStream = This.mixingStream(stream, localAudioStream);
                // session.processAddStream(mixStream, pc, 'audio')
            }
            This.setStream(stream, type, true);
            // session.processAddStream(stream, pc, type)

            console.info('share screen success');
            data.callback && data.callback({ codeType: This.CODE_TYPE.ACTION_SUCCESS, stream: stream, type: type });
            // session.setEncodingParameters('main')
        } else {
            console.warn('Get present stream failed: ' + event.error);
            // session.actionCallback = null
            var codeType = Record.prototype.getGumErrorCode('slides', event.error.name);
            data.callback && data.callback({ codeType: codeType });
        }
    }

    if (data.stream) {
        getMediaCallBack({ stream: data.stream });
    } else {
        This.getStreamFromDevice({ streamType: 'screenShare', constraints: data.constraints, callback: getMediaCallBack });
    }
};

Record.prototype.stopShare = function (data) {
    var This = this;
    console.info('stop share screen');
    if (!data) {
        console.info('invalid parameters to stop screen share');
        data && data.callback && data.callback({ codeType: This.CODE_TYPE.PARAMETER_ERROR });
        return;
    }

    var stopScreenCallback = function stopScreenCallback(event) {
        console.info('stop present callback data: ' + JSON.stringify(event, null, '    '));
        if (This.mixStreamContext) {
            This.mixStreamContext.close();
            This.mixStreamContext = null;
            // let audioStream = This.getStream('audio', true)
            // // session.processAddStream(audioStream, pc, 'audio')
        }
        if (event.codeType === 999) {
            console.info('stop present success');
            This.localStreams.slides = null;
            // session.setEncodingParameters('main')
        } else {
            console.warn('stop present failed');
        }
        data.callback && data.callback({ codeType: event.codeType });
    };

    var type = 'slides';
    var stream = This.getStream(type, true);
    if (stream) {
        console.info('clear previous stream');
        // session.processRemoveStream(stream, pc, type)
        This.closeStream(stream);
        This.setStream(null, type, true);
        stopScreenCallback({ codeType: This.CODE_TYPE.ACTION_SUCCESS });
    } else {
        console.warn('stop share screen: no present stream');
        stopScreenCallback({ codeType: This.CODE_TYPE.FAILED_TO_STOP_SCREEN_SHARE });
    }
};

/***************************************视频录制***************************************************/

Record.prototype.videoRecord = function (data) {
    console.info('recording video camera: ' + JSON.stringify(data, null, '    '));
    var This = this;
    var options = void 0;
    if (!data && !data.stream) {
        console.warn('shareVideo: invalid parameters');
        data && data.callback && data.callback({ codeType: This.CODE_TYPE.PARAMETER_ERROR });
        return;
    }

    if (This.currentRecoderType === 'audio') {
        options = {
            mimeType: 'audio/webm;codecs=opus;',
            audioBitsPerSecond: 128000, // 音频码率
            videoBitsPerSecond: 500000, // 视频码率
            ignoreMutedMedia: true
        };
    } else {
        options = {
            mimeType: 'video/webm;codecs=vp9;',
            audioBitsPerSecond: 128000, // 音频码率
            videoBitsPerSecond: 500000, // 视频码率
            ignoreMutedMedia: true
        };
    }

    // MediaRecorder.isTypeSupported 判断是否支持设置的视频格式
    if (!MediaRecorder.isTypeSupported(options.mimeType)) {
        console.error(options.mimeType + ' is not supported!');
        return;
    }

    function recordingCallback(event) {
        if (event.codeType === 999) {
            console.info('recording video success');
        } else {
            console.warn('recording video filed ' + event.codeType);
        }
        data.callback && data.callback({ codeType: event.codeType, stream: This.videoMediaRecorder });
    }

    try {
        This.videoMediaRecorder = new MediaRecorder(data.stream, options);
        This.videoMediaRecorder.recordedBlobs = [];
    } catch (e) {
        console.warn('Unable to create MediaRecorder with options Object: ', e);
    }

    This.videoMediaRecorder.start(10); // collect 10ms of data
    console.warn('MediaRecorder started', This.videoMediaRecorder);
    This.videoMediaRecorder.ondataavailable = handleDataAvailable;
    if (This.videoMediaRecorder) {
        recordingCallback({ codeType: 999, stream: This.videoMediaRecorder });
    } else {
        recordingCallback({ codeType: 201, stream: This.videoMediaRecorder });
    }

    function handleDataAvailable(event) {
        if (event.data && event.data.size > 0) {
            This.videoMediaRecorder.recordedBlobs.push(event.data);
        }
    }

    This.videoMediaRecorder.onstop = function () {
        if (This.videoMediaRecorder.state === 'inactive') {
            console.warn("********* stop success***********");
            // data.callback && data.callback({ codeType: 999, stream: This.videoMediaRecorder})
        }
    };

    This.videoMediaRecorder.onpause = function () {
        if (This.videoMediaRecorder.state === 'paused') {
            console.warn("********* pause success***********");
        }
    };

    This.videoMediaRecorder.onresume = function () {
        if (This.videoMediaRecorder.state === 'recording') {
            console.warn("********* resume success ***********");
        }
    };
};

Record.prototype.stopVideoRecord = function (data) {
    console.log('Recorder stopped: ', data);
    var This = this;
    This.videoMediaRecorder.stop();
    This.videoMediaRecorder.onstop = function () {
        /**录制返回播放**/
        // let blob = new Blob(This.mediaRecorder.recordedBlobs, {'type': 'video/webm'});
        // let url = window.URL.createObjectURL(blob);
        // if (data.type === 'video' || data.type === 'shareScreen') {
        //     recordVideo.srcObject = null;
        // }
        // recordVideo.src = url;
        console.warn("********************");
    };

    This.videoMediaRecorder.addEventListener('dataavailable', function (event) {
        if (event.data && event.data.size > 0) {
            This.videoMediaRecorder.recordedBlobs.push(event.data);
        }
    });

    if (This.videoMediaRecorder.state === 'inactive') {
        console.warn("********* stop success***********");
        data.callback && data.callback({ codeType: 999, stream: This.videoMediaRecorder });
    }
};

Record.prototype.videoDownload = function (data) {
    var This = this;
    var type = void 0;
    if (window.record.currentRecoderType === 'audio') {
        type = { type: 'audio/webm' };
    } else {
        type = { type: 'video/webm' };
    }
    var blob = new Blob(This.videoMediaRecorder.recordedBlobs, type);
    var url = window.URL.createObjectURL(blob);
    var a = document.createElement('a');
    a.target = "_blank";
    a.style.display = 'none';
    a.href = url;
    a.download = 'test.webm';
    document.body.appendChild(a);
    a.click();
    setTimeout(function () {
        document.body.removeChild(a);
        window.URL.revokeObjectURL(url);
    }, 100);

    data.callback && data.callback({ codeType: 999, file: a });
};

/***********************************************音频录制****************************************************/

Record.prototype.audioRecord = function (data) {
    console.info('recording audio MIC: ' + JSON.stringify(data, null, '    '));
    var This = this;
    if (!data && !data.stream) {
        console.warn('shareAudio: invalid parameters');
        data && data.callback && data.callback({ codeType: This.CODE_TYPE.PARAMETER_ERROR });
        return;
    }
    var options = {
        mimeType: 'audio/webm;codecs=opus;',
        audioBitsPerSecond: 128000, // 音频码率
        videoBitsPerSecond: 500000, // 视频码率
        ignoreMutedMedia: true
    };

    // MediaRecorder.isTypeSupported 判断是否支持设置的视频格式
    if (!MediaRecorder.isTypeSupported(options.mimeType)) {
        console.error(options.mimeType + ' is not supported!');
        return;
    }

    function recordingCallback(event) {
        if (event.codeType === 999) {
            console.info('recording video success');
        } else {
            console.warn('recording video filed ' + event.codeType);
        }
        data.callback && data.callback({ codeType: event.codeType, stream: This.audioMediaRecorder });
    }

    try {
        This.audioMediaRecorder = new MediaRecorder(data.stream, options);
        This.audioMediaRecorder.recordedBlobs = [];
    } catch (e) {
        console.log('Unable to create MediaRecorder with options Object: ', e);
    }

    This.audioMediaRecorder.start(10); // collect 10ms of data
    console.log('MediaRecorder started', This.audioMediaRecorder);
    This.audioMediaRecorder.ondataavailable = handleDataAvailable;
    if (This.audioMediaRecorder) {
        recordingCallback({ codeType: 999, stream: This.audioMediaRecorder });
    } else {
        recordingCallback({ codeType: 201, stream: This.audioMediaRecorder });
    }

    function handleDataAvailable(event) {
        if (event.data && event.data.size > 0) {
            This.audioMediaRecorder.recordedBlobs.push(event.data);
        }
    }
};

Record.prototype.stopAudioRecord = function (data) {
    console.log('Recorder stopped: ', data);
    var This = this;
    This.audioMediaRecorder.onstop = function () {
        /**录制返回播放**/
        // let blob = new Blob(This.mediaRecorder.recordedBlobs, {'type': 'video/webm'});
        // let url = window.URL.createObjectURL(blob);
        // if (data.type === 'video' || data.type === 'shareScreen') {
        //     recordVideo.srcObject = null;
        // }
        // recordVideo.src = url;
        console.warn("********************");
    };

    This.audioMediaRecorder.addEventListener('dataavailable', function (event) {
        if (event.data && event.data.size > 0) {
            This.audioMediaRecorder.recordedBlobs.push(event.data);
        }
    });

    data.callback && data.callback({ codeType: 999, Blobs: This.audioMediaRecorder.recordedBlobs });
};

Record.prototype.audioDownload = function (data) {
    var This = this;
    var blob = new Blob(This.videoMediaRecorder.recordedBlobs, { type: 'audio/ogg' });
    var url = window.URL.createObjectURL(blob);
    var a = document.createElement('a');
    a.target = "_blank";
    a.style.display = 'none';
    a.href = url;
    a.download = 'audio.ogg';
    document.body.appendChild(a);
    a.click();
    setTimeout(function () {
        document.body.removeChild(a);
        window.URL.revokeObjectURL(url);
    }, 100);

    data.callback && data.callback({ codeType: 999, file: a });
};
Record.prototype.getBrowserDetail = function () {
    function extractVersion(uastring, expr, pos) {
        var match = uastring.match(expr);
        return match && match.length >= pos && parseInt(match[pos], 10);
    }

    var navigator = window && window.navigator;

    // Returned result object.
    var result = {};
    result.browser = null;
    result.version = null;
    result.UIVersion = null;
    result.chromeVersion = null;
    result.systemFriendlyName = null;

    if (navigator.userAgent.match(/Windows/)) {
        result.systemFriendlyName = 'windows';
    } else if (navigator.userAgent.match(/Mac/)) {
        result.systemFriendlyName = 'mac';
    } else if (navigator.userAgent.match(/Linux/)) {
        result.systemFriendlyName = 'linux';
    }

    // Fail early if it's not a browser
    if (typeof window === 'undefined' || !window.navigator) {
        result.browser = 'Not a browser.';
        return result;
    }

    // Edge.
    if (navigator.mediaDevices && navigator.userAgent.match(/Edge\/(\d+).(\d+)$/)) {
        result.browser = 'edge';
        result.version = extractVersion(navigator.userAgent, /Edge\/(\d+).(\d+)$/, 2);
        result.UIVersion = navigator.userAgent.match(/Edge\/([\d.]+)/)[1]; // Edge/16.17017
    } else if (!navigator.mediaDevices && (!!window.ActiveXObject || 'ActiveXObject' in window || navigator.userAgent.match(/MSIE (\d+)/) || navigator.userAgent.match(/rv:(\d+)/))) {
        // IE
        result.browser = 'ie';
        if (navigator.userAgent.match(/MSIE (\d+)/)) {
            result.version = extractVersion(navigator.userAgent, /MSIE (\d+).(\d+)/, 1);
            result.UIVersion = navigator.userAgent.match(/MSIE ([\d.]+)/)[1]; // MSIE 10.6
        } else if (navigator.userAgent.match(/rv:(\d+)/)) {
            /* For IE 11 */
            result.version = extractVersion(navigator.userAgent, /rv:(\d+).(\d+)/, 1);
            result.UIVersion = navigator.userAgent.match(/rv:([\d.]+)/)[1]; // rv:11.0
        }

        // Firefox.
    } else if (navigator.mozGetUserMedia) {
        result.browser = 'firefox';
        result.version = extractVersion(navigator.userAgent, /Firefox\/(\d+)\./, 1);
        result.UIVersion = navigator.userAgent.match(/Firefox\/([\d.]+)/)[1]; // Firefox/56.0

        // all webkit-based browsers
    } else if (navigator.webkitGetUserMedia && window.webkitRTCPeerConnection) {
        // Chrome, Chromium, Webview, Opera, Vivaldi all use the chrome shim for now
        var isOpera = !!navigator.userAgent.match(/(OPR|Opera).([\d.]+)/);
        // var isVivaldi = navigator.userAgent.match(/(Vivaldi).([\d.]+)/) ? true : false;
        if (isOpera) {
            result.browser = 'opera';
            result.version = extractVersion(navigator.userAgent, /O(PR|pera)\/(\d+)\./, 2);
            result.UIVersion = navigator.userAgent.match(/O(PR|pera)\/([\d.]+)/)[2]; // OPR/48.0.2685.39
            if (navigator.userAgent.match(/Chrom(e|ium)\/([\d.]+)/)[2]) {
                result.chromeVersion = extractVersion(navigator.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
            }
        } else {
            result.browser = 'chrome';
            result.version = extractVersion(navigator.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
            result.UIVersion = navigator.userAgent.match(/Chrom(e|ium)\/([\d.]+)/)[2]; // Chrome/61.0.3163.100
        }
    } else if (!navigator.webkitGetUserMedia && navigator.userAgent.match(/AppleWebKit\/([0-9]+)\./) || navigator.webkitGetUserMedia && !navigator.webkitRTCPeerConnection) {
        if (navigator.userAgent.match(/Version\/(\d+).(\d+)/)) {
            result.browser = 'safari';
            result.version = extractVersion(navigator.userAgent, /AppleWebKit\/(\d+)\./, 1);
            result.UIVersion = navigator.userAgent.match(/Version\/([\d.]+)/)[1]; // Version/11.0.1
        } else {
            // unknown webkit-based browser.
            result.browser = 'Unsupported webkit-based browser ' + 'with GUM support but no WebRTC support.';
            return result;
        }
        // Default fallthrough: not supported.
    } else {
        result.browser = 'Not a supported browser.';
        return result;
    }

    return result;
};

/**
 * 判断共享桌面时是否支持共享音频
 * */
Record.prototype.isSystemAudioShareSupport = function () {
    var result = false;
    var browserDetail = this.getBrowserDetail();
    if (browserDetail.browser === 'chrome' && navigator.userAgent.indexOf('Edg') > 0 && browserDetail.version >= 79 || // chrome 内核Edge
    browserDetail.browser === 'chrome' && navigator.userAgent.indexOf('Edg') < 0 && browserDetail.version >= 74 || browserDetail.browser === 'opera' && browserDetail.version >= 74) {
        result = true;
    }
    return result;
};

Record.prototype.setVideoUpResolution = function (constraints) {
    if (!constraints || !constraints.video || !constraints.video.height || !constraints.video.width) {
        return;
    }

    this.RESOLUTION.VIDEO_CURRENT_UP = {
        width: constraints.video.width.exact || constraints.video.width.ideal || constraints.video.width.max || constraints.video.width,
        height: constraints.video.height.exact || constraints.video.height.ideal || constraints.video.height.max || constraints.video.height
    };
    console.info('set video up resolution: ' + this.RESOLUTION.VIDEO_CURRENT_UP.width + '*' + this.RESOLUTION.VIDEO_CURRENT_UP.height);
};

Record.prototype.mixingStream = function (stream1, stream2) {
    console.info('mixing audio stream');
    // 混音参数
    var context = void 0;
    window.AudioContext = window.AudioContext || window.webkitAudioContext || window.mozAudioContext || window.msAudioContext;
    if (window.AudioContext) {
        context = new window.AudioContext();
    } else {
        console.error('not support web audio api');
    }

    // 混音
    var destinationParticipant1 = context.createMediaStreamDestination();
    if (stream1) {
        var source1 = context.createMediaStreamSource(stream1);
        source1.connect(destinationParticipant1);
    }
    if (stream2) {
        var source2 = context.createMediaStreamSource(stream2);
        source2.connect(destinationParticipant1);
    }

    return destinationParticipant1.stream;
};

Record.prototype.enumDevices = function (deviceInfoCallback) {
    if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
        console.warn("browser don't support enumerateDevices() .");
        return;
    }

    function getDeviceInfos(deviceInfos) {
        var microphone = [];
        var speaker = [];
        var camera = [];
        var screenResolution = [];
        var isConstraintsKeywordSupport = true;
        for (var i = 0; i < deviceInfos.length; i++) {
            var deviceInfo = deviceInfos[i];
            if (deviceInfo.deviceId === 'default' || deviceInfo.deviceId === 'communications') {
                continue;
            }
            if (deviceInfo.kind === 'audioinput') {
                microphone.push({
                    label: deviceInfo.label,
                    deviceId: deviceInfo.deviceId,
                    groupId: deviceInfo.groupId,
                    status: 'available'
                });
            }
            if (deviceInfo.kind === 'audiooutput') {
                speaker.push({
                    label: deviceInfo.label,
                    deviceId: deviceInfo.deviceId,
                    groupId: deviceInfo.groupId,
                    status: 'available'
                });
            }
            if (deviceInfo.kind === 'videoinput') {
                camera.push({
                    label: deviceInfo.label,
                    deviceId: deviceInfo.deviceId,
                    groupId: deviceInfo.groupId,
                    status: 'available',
                    capability: []
                });
            }
        }

        // screenResolution.push({
        //     width: window.screen.width,
        //     height: window.screen.height
        // })

        var getDeviceds = {
            microphones: microphone,
            speakers: speaker,
            cameras: camera
            // screenResolution: screenResolution,
            // isConstraintsKeywordSupport: isConstraintsKeywordSupport
        };
        if (deviceInfoCallback) {
            console.warn(" getDeviceds:", getDeviceds);
            deviceInfoCallback && deviceInfoCallback.callback(getDeviceds);
        } else {
            return {
                microphones: microphone,
                speakers: speaker,
                cameras: camera
                // screenResolution: screenResolution,
                // isConstraintsKeywordSupport: isConstraintsKeywordSupport
            };
        }
    }

    function getDeviceInfosFailed(err) {
        console.error(err);
        deviceInfoCallback && deviceInfoCallback.callback(err);
    }

    navigator.mediaDevices.enumerateDevices().then(getDeviceInfos).catch(getDeviceInfosFailed);
};
function openAudio(data) {
    console.warn("openAudio:" + JSON.stringify(data, null, '    '));
    if (!data || !data.callback) {
        console.warn("openAudio: invalid parameters");
    }
    data.constraints = {
        audio: { deviceId: data && data.deviceId } || false
    };
    window.record.openAudio(data);
}

function switchLocalAudioDeviced(data) {
    console.warn("switchAudio:" + JSON.stringify(data, null, '    '));
    if (!data || !data.callback) {
        console.warn("switchAudio: invalid parameters");
    }
    data.constraints = {
        audio: { deviceId: data && data.deviceId } || true
    };
    delete data.deviceId;
    window.record.switchLocalAudioDevice(data);
}

function stopAudio(data) {
    console.warn("stopAudio:" + JSON.stringify(data, null, '    '));
    if (!data || !data.callback) {
        console.warn("stopAudio: invalid parameters");
    }
    window.record.stopAudio(data);
}

function openVideo(data) {
    console.warn("openVideo:" + JSON.stringify(data, null, '    '));
    if (!data || !data.callback) {
        console.warn("openVideo: invalid parameters");
    }

    if (window.record.currentRecoderType === 'areaVideo') {
        data.constraints = {
            audio: false,
            video: {
                width: 1920, // 必须
                height: 1080, // 必须
                frameRate: 15, // 可缺省，默认15fps
                deviceId: data && data.deviceId ? data.deviceId : ''
            }
        };
    } else {
        data.constraints = {
            audio: false,
            video: {
                width: 1080, // 必须
                height: 720, // 必须
                frameRate: 15, // 可缺省，默认15fps
                deviceId: data && data.deviceId ? data.deviceId : ''
            }
        };
    }
    window.record.openVideo(data);
}

function switchLocalVideoDeviced(data) {
    console.warn("switchVideo:" + JSON.stringify(data, null, '    '));
    if (!data || !data.deviceId || !data.callback) {
        console.warn("switchVideo: invalid parameters");
    }

    if (window.record.currentRecoderType === 'areaVideo') {
        data.constraints = {
            audio: false,
            video: {
                width: 1920, // 必须
                height: 1080, // 必须
                frameRate: 15, // 可缺省，默认15fps
                deviceId: data && data.deviceId ? data.deviceId : ''
            }
        };
    } else {
        data.constraints = {
            audio: false,
            video: {
                width: 1080, // 必须
                height: 720, // 必须
                frameRate: 15, // 可缺省，默认15fps
                deviceId: data && data.deviceId ? data.deviceId : ''
            }
        };
    }
    window.record.switchLocalVideoDevice(data);
}

function stopVideo(data) {
    console.warn("stopVideo:" + JSON.stringify(data, null, '    '));
    if (!data || !data.callback) {
        console.warn("openAreaVideo: invalid parameters");
    }
    window.record.stopVideo(data);
}

function openShare(data) {
    console.warn("openAreaVideo:" + JSON.stringify(data, null, '    '));
    if (!data) {
        console.warn("openAreaVideo: invalid parameters");
    }
    if (window.record.currentRecoderType === 'areaVideo') {
        data.constraints = {
            audio: false,
            // video: {mediaSource: 'screen'}
            video: {
                width: 1920, // 必须
                height: 1080, // 必须
                frameRate: 15 // 可缺省，默认15fps
            }
        };
    } else {
        data.constraints = {
            audio: false,
            video: {
                width: 1920, // 必须
                height: 1080, // 必须
                frameRate: 15 // 可缺省，默认15fps
            }
        };
    }

    window.record.openShare(data);
}

function stopShare(data) {
    console.warn("stopShare:" + JSON.stringify(data, null, '    '));
    if (!data || !data.callback) {
        console.warn("stopVideo: invalid parameters");
    }
    window.record.stopShare(data);
}

(function () {
    var mouseStopId;
    var mouseOn = false;
    var startX = 0;
    var startY = 0;
    var shareVideo = document.getElementsByClassName("shareVideo")[0];
    var shareTip = document.getElementById("container");
    var videoArea = document.getElementsByClassName("videoArea")[0];
    videoArea.onmousedown = function (e) {
        clearEventBubble(e);
        if (e.buttons !== 1 || e.which !== 1) return;

        mouseStopId = setTimeout(function () {
            mouseOn = true;
            // 获取容器元素
            // var videoArea = document.getElementById('videoArea');
            // 调整坐标原点为容器左上角
            startX = e.clientX - videoArea.offsetLeft + videoArea.scrollLeft;
            startY = e.clientY - videoArea.offsetTop + videoArea.scrollTop;
            var selDiv = document.createElement('div');
            selDiv.style.cssText = 'position:absolute;width:0;height:0;margin:0;padding:0;border:1px dashed #eee;background-color:#aaa;z-index:1000;opacity:0.6;display:none;';
            selDiv.id = 'selectDiv';
            // 添加框选元素到容器内
            videoArea.appendChild(selDiv);
            selDiv.style.left = startX + 'px';
            selDiv.style.top = startY + 'px';

            window.startPositionX = event.clientX - shareTip.offsetLeft - shareVideo.offsetLeft;
            window.startPositionY = event.clientY - shareTip.offsetTop - shareVideo.offsetTop;
        }, 300);
    };

    videoArea.onmousemove = function (e) {
        if (!mouseOn) return;
        clearEventBubble(e);
        var _x = e.clientX - videoArea.offsetLeft + videoArea.scrollLeft;
        var _y = e.clientY - videoArea.offsetTop + videoArea.scrollTop;
        var _H = videoArea.clientHeight;
        // 鼠标移动超出容器内部，进行相应的处理
        // 向下拖拽
        if (_y >= _H && videoArea.scrollTop <= _H) {
            videoArea.scrollTop += _y - _H;
        }
        // 向上拖拽
        if (e.clientY <= videoArea.offsetTop && videoArea.scrollTop > 0) {
            videoArea.scrollTop = Math.abs(e.clientY - videoArea.offsetTop);
        }
        var selDiv = document.getElementById('selectDiv');
        selDiv.style.display = 'block';
        selDiv.style.left = Math.min(_x, startX) + 'px';
        selDiv.style.top = Math.min(_y, startY) + 'px';
        selDiv.style.width = Math.abs(_x - startX) + 'px';
        selDiv.style.height = Math.abs(_y - startY) + 'px';
    };

    videoArea.onmouseup = function (e) {
        if (!mouseOn) return;
        clearEventBubble(e);
        var selDiv = document.getElementById('selectDiv');
        var fileDivs = document.getElementsByClassName('fileDiv');
        var selectedEls = [];
        var l = selDiv.offsetLeft;
        var t = selDiv.offsetTop;
        var w = selDiv.offsetWidth;
        var h = selDiv.offsetHeight;
        for (var i = 0; i < fileDivs.length; i++) {
            var sl = fileDivs[i].offsetWidth + fileDivs[i].offsetLeft;
            var st = fileDivs[i].offsetHeight + fileDivs[i].offsetTop;

            if (sl > l && st > t && fileDivs[i].offsetLeft < l + w && fileDivs[i].offsetTop < t + h) {
                selectedEls.push(fileDivs[i]);
            }
        }
        window.endPositionX = e.clientX - shareTip.offsetLeft - shareVideo.offsetLeft;
        window.endPositionY = e.clientY - shareTip.offsetTop - shareVideo.offsetTop;
        console.log(selectedEls);
        selDiv.style.display = 'none';
        mouseOn = false;
    };

    function clearEventBubble(e) {
        if (e.stopPropagation) e.stopPropagation();else e.cancelBubble = true;

        if (e.preventDefault) e.preventDefault();else e.returnValue = false;
    }
})();

Record.prototype.preInit = function () {
    console.info('create new Record object');
    try {
        window.record = new Record({});
    } catch (e) {
        console.error(e.toString());
    }
};

function Record() {
    console.warn("init record....");
    this.constraints = { audio: true, video: { width: 640, height: 360 } };
    this.videoUpResolution = null; // 当前主流上行分辨率

    // 录制内容
    this.mediaRecorder = null;
    this.recordedBlobs = null;
    this.currentRecoderType = null;
    this.isUploadVideo = false;
    this.isMute = false;

    this.localStreams = {
        audio: null,
        main: null,
        slides: null
    };
    this.RESOLUTION = {
        VIDEO_DEFAULT: { width: 640, height: 360 },
        VIDEO_CURRENT_UP: null, // 主流当前上行分辨率
        VIDEO_EXPECT_RECV: null, // 期望收到的下行分辨率
        SLIDES_CURRENT_UP: null
    };
}

Record.prototype.CODE_TYPE = {
    // 接口参数错误时的统一错误码
    PARAMETER_ERROR: 16,
    COMMON_ERROR: 17,

    // 业务错误码 100 - 199
    INCOMING_CALL_CANCELED: 101, // 来电被取消
    COULD_NOT_ESTABLISH_NEW_CALL: 102,
    FAILED_TO_CALL: 103,
    UNSUPPORT_CALL_TYPE: 104,
    FAILED_TO_REGISTER: 105,
    REQUEST_RESPONSE_TIMEOUT: 106,

    // MIC业务错误码
    FAILED_TO_MUTE_MIC: 110,
    FAILED_TO_UNMUTE_MIC: 111,

    // 摄像头业务错误码
    FAILED_TO_ADJUST_RESOLUTION: 113,
    FAILED_TO_VIDEO_ON: 114,
    CAMERA_NOT_SUPPORT: 115,
    SERVER_RESOURCE_REACHED_LIMIT: 116,
    FAILED_TO_CLOSE_LOCAL_VIDEO: 117,
    FAILED_TO_OPEN_LOCAL_VIDEO: 118,

    // 服务器错误码
    CODE_NOT_SUPPORT: 119,
    SERVER_CPU_LIMIT: 120,

    // 桌面共享错误码
    CANCEL_TO_SCREEN_SHARE: 121,
    FAILED_TO_SCREEN_SHARE: 122,
    SHARE_STREAM_STOPPED_BY_CONTROL_BAR: 124,
    FAILED_TO_STOP_SCREEN_SHARE: 125,
    FAILED_TO_SWITCH_SCREEN_STREAM: 127,
    FAILED_TO_SWITCH_CALL: 128,

    FAILED_TO_SEND_INFO: 133,
    FAILED_TO_SEND_MESSAGE: 134,
    FAILED_TO_HOLD: 135,
    FAILED_TO_RESUME: 136,

    // websocket重连
    WEBSOCKET_RECONNECTION_FAILED: 137,
    WEBSOCKET_CONNECTING: 138,
    WEBSOCKET_CLOSE: 139,

    // ICE 重连
    ICE_CONNECTION_FAILED: 151,
    ICE_RECONNECTING: 152,
    ICE_RECONNECTED_FAILED: 153,

    // 麦克风请求错误码
    MIC_NOT_FOUND: 932, // 没有找到可以设备
    MIC_NOT_READABLE: 933, // 无法读取麦克风设备
    MIC_REQUEST_REFUSE: 941, // 麦克风禁用
    MIC_REQUEST_FAIL: 942, // 麦克风开启失败
    MIC_REQUEST_CLOSE: 943,
    MIC_TYPE_ERROR: 944, // 必须至少请求一个音频或视频

    // 摄像头请求错误码
    VIDEO_REQUEST_REFUSE: 945, // 摄像头禁用
    VIDEO_REQUEST_OCCUPY: 946,
    VIDEO_REQUEST_BEYOND: 948,
    VIDEO_REQUEST_FAIL: 949, // 摄像头开启失败
    VIDEO_NOT_FOUND: 950, // 没有找到可以设备
    VIDEO_TYPE_ERROR: 951, // 必须至少请求一个音频或视频
    VIDEO_NOT_READABLE: 952, // 无法读取摄像头设备
    VIDEO_REQUEST_OVER_CONSTRAINTS: 953, // 取流约束超出设备限制能力

    // 共享桌面请求错误码
    SCREEN_NOT_READABLE: 954,
    SCREEN_REQUEST_REFUSE: 955,
    SCREEN_NOT_FOUND: 956,
    SCREEN_INVALID_STATE: 957,
    SCREEN_ABORT_ERROR: 958,
    SCREEN_TYPE_ERROR: 959,
    SCREEN_REQUEST_OVER_CONSTRAINTS: 960,

    // success code
    ACTION_SUCCESS: 999
};
function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

Record.prototype.getMedia = function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(data, constraints) {
        var onGetStreamSuccess, onGetStreamFailed, videoTrack, constraintsOfApply;
        return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
                switch (_context.prev = _context.next) {
                    case 0:
                        onGetStreamFailed = function onGetStreamFailed(error) {
                            data.error = error;
                            console.warn('get stream failed: ' + JSON.stringify(constraints, null, '  '));
                            console.warn('onGetStreamFailed error message: ' + error.message);
                            console.warn('error name: ' + error.name);
                            console.warn('error constraint: ' + error.constraints);
                            if (error.name === 'OverconstrainedError' || error.name === 'ConstraintNotSatisfiedError') {
                                // constraints can not be satisfied by avb.device
                                console.info('constraints can not be satisfied by avb.device');
                                data.callback({ error: error, constraints: constraints });
                            } else {
                                if (error.name === 'NotFoundError' || error.name === 'DeviceNotFoundError') {
                                    // require track is missing
                                    console.info('require track is missing');
                                } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
                                    // webcam or mic are already in use
                                    console.info('webcam or mic are already in use');
                                } else if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError' || error.name === 'PermissionDismissedError') {
                                    // permission denied in browser
                                    console.info('permission denied in browser');
                                } else if (error.name === 'TypeError') {
                                    // empty constraints object
                                    console.info('empty constraints object');
                                } else {
                                    // other errors
                                    console.info('other errors ' + error.name);
                                }
                                data.callback({ error: error });
                            }
                        };

                        onGetStreamSuccess = function onGetStreamSuccess(stream) {
                            console.info('get stream success constraints: ' + JSON.stringify(constraints, null, '  '));
                            data.callback({ stream: stream || data.stream });
                        };

                        console.warn(' getMedia ');


                        if (data.streamType === 'audio') {
                            navigator.mediaDevices.getUserMedia(constraints).then(onGetStreamSuccess).catch(onGetStreamFailed);
                        } else if (data.streamType === 'video') {
                            if (!data.isFirefox && data.stream && data.stream.getVideoTracks().length && data.stream.active) {
                                videoTrack = void 0;
                                constraintsOfApply = {
                                    width: { exact: constraints.video.width.exact },
                                    height: { exact: constraints.video.height.exact }
                                };

                                videoTrack = data.stream.getVideoTracks()[0];
                                if (videoTrack && videoTrack.applyConstraints) {
                                    console.info('applyConstraints constraints: ' + JSON.stringify(constraintsOfApply, null, '    '));
                                    videoTrack.applyConstraints(constraintsOfApply).then(function () {
                                        console.info('video applyConstraints success!');
                                        data.callback({ stream: data.stream });
                                    }).catch(onGetStreamFailed);
                                }
                            } else {
                                navigator.mediaDevices.getUserMedia(constraints).then(onGetStreamSuccess).catch(onGetStreamFailed);
                            }
                        } else if (data.streamType === 'screenShare') {
                            if (window.ipcRenderer) {
                                console.info('ipcRenderer getUserMedia for screen');
                                navigator.mediaDevices.getUserMedia(constraints).then(onGetStreamSuccess).catch(onGetStreamFailed);
                            } else {
                                if (navigator.getDisplayMedia) {
                                    // for Edge old version
                                    navigator.getDisplayMedia(constraints).then(onGetStreamSuccess).catch(onGetStreamFailed);
                                } else if (navigator.mediaDevices.getDisplayMedia) {
                                    // for all supported getDisplayMedia browser versions
                                    navigator.mediaDevices.getDisplayMedia(constraints).then(onGetStreamSuccess).catch(onGetStreamFailed);
                                } else if (navigator.mediaDevices.getUserMedia) {
                                    navigator.mediaDevices.getUserMedia(constraints).then(onGetStreamSuccess).catch(onGetStreamFailed);
                                } else {
                                    console.info('getDisplayMedia is not supported by current browser');
                                }
                            }
                        }

                    case 4:
                    case 'end':
                        return _context.stop();
                }
            }
        }, _callee, this);
    }));

    return function (_x, _x2) {
        return _ref.apply(this, arguments);
    };
}();

Record.prototype.setStream = function (stream, type, isLocal, msid) {
    var This = this;
    if (!type) {
        console.warn('setStream: Invalid parameter!');
        return;
    }

    var streamId = stream ? stream.id : null;
    console.info('set ' + type + ' stream id: ' + streamId);
    if (isLocal) {
        if (This.localStreams[type]) {
            This.closeStream(This.localStreams[type]); // clear before first
        }
        This.localStreams[type] = stream;
    } else {
        if (type === 'audio' || type === 'main' || type === 'slides') {
            // This.remoteStreams[type] = stream
        } else {
            if (!stream) {
                // delete This.remoteStreams.mainVideos[type]
            } else {
                    // This.remoteStreams.mainVideos[type] = stream
                }
        }
    }
};

Record.prototype.getStream = function (type, isLocal) {
    if (!type) {
        console.warn('getStream: Invalid parameter!');
        return;
    }

    var stream = void 0;
    if (isLocal) {
        stream = this.localStreams[type];
    } else {
        if (type === 'audio' || type === 'main' || type === 'slides') {
            // stream = this.remoteStreams[type]
        } else {
                // stream = this.remoteStreams.mainVideos[type]
            }
    }

    if (stream) {
        console.info('get ' + type + ' stream id :' + stream.id);
    } else {
        console.warn(type + ' stream does not exist');
    }
    return stream;
};

Record.prototype.getGumErrorCode = function (streamType, errorName) {
    var This = this;
    var errorCode = void 0;
    if (streamType === 'audio') {
        if (errorName === "NotFoundError" || errorName === "DevicesNotFoundError") {
            //required track is missing
            errorCode = Record.prototype.CODE_TYPE.MIC_NOT_FOUND;
        } else if (errorName === "NotReadableError" || errorName === "TrackStartError") {
            //webcam or mic are already in use
            errorCode = Record.prototype.CODE_TYPE.MIC_NOT_READABLE;
        } else if (errorName === "NotAllowedError" || errorName === "PermissionDeniedError" || errorName && errorName.indexOf("denied") !== -1) {
            //permission denied in browser
            errorCode = Record.prototype.CODE_TYPE.MIC_REQUEST_REFUSE;
        } else if (errorName === "TypeError") {
            //empty constraints object
            errorCode = Record.prototype.CODE_TYPE.MIC_TYPE_ERROR;
        } else {
            //other errors
            errorCode = Record.prototype.CODE_TYPE.MIC_REQUEST_FAIL;
        }
    } else if (streamType === 'video') {
        if (errorName === "OverconstrainedError" || errorName === "ConstraintNotSatisfiedError" || errorName === "InternalError") {
            //constraints can not be satisfied by avb. devices
            errorCode = Record.prototype.CODE_TYPE.VIDEO_REQUEST_OVER_CONSTRAINTS;
        } else if (errorName === "NotFoundError" || errorName === "DevicesNotFoundError") {
            //required track is missing
            errorCode = Record.prototype.CODE_TYPE.VIDEO_NOT_FOUND;
        } else if (errorName === "NotReadableError" || errorName === "TrackStartError") {
            //webcam or mic are already in use
            errorCode = Record.prototype.CODE_TYPE.VIDEO_NOT_READABLE;
        } else if (errorName === "NotAllowedError" || errorName === "PermissionDeniedError" || errorName && errorName.indexOf("denied") !== -1) {
            //permission denied in browser
            errorCode = Record.prototype.CODE_TYPE.VIDEO_REQUEST_REFUSE;
        } else if (errorName === "TypeError") {
            //empty constraints object
            errorCode = Record.prototype.CODE_TYPE.VIDEO_TYPE_ERROR;
        } else {
            //other errors
            errorCode = Record.prototype.CODE_TYPE.VIDEO_REQUEST_FAIL;
        }
    } else if (streamType === 'slides') {
        if (errorName === 'NotReadableError') {
            errorCode = Record.prototype.CODE_TYPE.SCREEN_NOT_READABLE;
        } else if (errorName === 'NotAllowedError') {
            errorCode = Record.prototype.CODE_TYPE.SCREEN_REQUEST_REFUSE;
        } else if (errorName === 'OverconstrainedError') {
            errorCode = Record.prototype.CODE_TYPE.SCREEN_REQUEST_OVER_CONSTRAINTS;
        } else if (errorName === 'NotFoundError') {
            // There is no screen video source available for capture
            errorCode = Record.prototype.CODE_TYPE.SCREEN_NOT_FOUND;
        } else if (errorName === 'InvalidStateError') {
            // The document in the context is not fully activated
            errorCode = Record.prototype.CODE_TYPE.SCREEN_INVALID_STATE;
        } else if (errorName === 'AbortError') {
            // Mismatched errors or malfunctions.
            errorCode = Record.prototype.CODE_TYPE.SCREEN_ABORT_ERROR;
        } else if (errorName === 'TypeError') {
            // Unsupported constraints
            errorCode = Record.prototype.CODE_TYPE.SCREEN_TYPE_ERROR;
        } else {
            //other errors
            errorCode = Record.prototype.CODE_TYPE.FAILED_TO_SCREEN_SHARE;
        }
    }

    console.info("gum error " + errorName + ", code " + errorCode);
    return errorCode;
};

Record.prototype.getStreamFromDevice = function (data) {
    var This = this;
    if (!data) {
        console.error('getStreamFromDevice: invalid parameters');
        return;
    } else {
        console.warn("getStreamFromDevice constraints:", data);
    }

    var constraints = {};
    switch (data.streamType) {
        case 'audio':
            constraints = {
                audio: data.constraints.audio.deviceId ? { deviceId: { exact: data.constraints.audio.deviceId } } : true,
                video: false
            };

            break;
        case 'video':
            constraints = {
                // data.constraints.audio ? (data.constraints.audio.deviceId ? {deviceId: { exact: data.constraints.audio.deviceId }} : data.constraints.audio) :data.constraints.audio,
                audio: false,
                video: {
                    width: { exact: data.constraints.video.width ? data.constraints.video.width : 640 },
                    height: { exact: data.constraints.video.height ? data.constraints.video.height : 360 },
                    deviceId: data.constraints.video.deviceId ? { exact: data.constraints.video.deviceId } : ''
                }
            };
            if (Record.prototype.getBrowserDetail().browser !== 'firefox') {
                constraints.video.frameRate = { exact: data.constraints.video.frameRate ? data.constraints.video.frameRate : 15 };
            }
            break;
        case 'screenShare':
            if (window.ipcRenderer) {
                console.info('desktop share');
                constraints = {
                    audio: false,
                    video: {
                        mandatory: {
                            chromeMediaSource: data.constraints.video.mandatory.chromeMediaSource || 'desktop',
                            chromeMediaSourceId: data.constraints.video.mandatory.chromeMediaSourceId,
                            maxWidth: data.constraints.video.mandatory.maxWidth || 1920,
                            maxHeight: data.constraints.video.mandatory.maxHeight || 1080,
                            minWidth: data.constraints.video.mandatory.minWidth || 1280,
                            minHeight: data.constraints.video.mandatory.minHeight || 720,
                            maxFrameRate: data.constraints.video.mandatory.maxFrameRate || 5
                        }
                    }
                };
                if (data.constraints.video.mandatory.chromeMediaSource) {
                    constraints.video.mandatory.chromeMediaSource = data.constraints.video.mandatory.chromeMediaSource;
                }
            } else {
                constraints = {
                    audio: Record.prototype.isSystemAudioShareSupport(),
                    // video: data.constraints.video.mediaSource,
                    video: {
                        width: { max: data.constraints.video.width ? data.constraints.video.width : 1920 },
                        height: { max: data.constraints.video.height ? data.constraints.video.height : 1080 },
                        frameRate: { max: data.constraints.video.frameRate ? data.constraints.video.frameRate : 15 }
                    }
                };
            }
            break;
        default:
            console.warn('Unknown type: ' + data.streamType);
            break;
    }

    var parameters = {
        streamType: data.streamType,
        stream: data.stream,
        // isFirefox: GsRTC.prototype.getBrowserDetail().browser === 'firefox',
        callback: data.callback
    };
    record.getMedia(parameters, constraints);
};

Record.prototype.streamMuteSwitch = function (data) {
    var This = this;
    if (data.stream != null) {
        console.info('MuteStream: stream id = ' + data.stream.id);
    } else {
        console.warn('stream is not exist!');
        return;
    }

    if (data && data.stream && data.type === 'audio' && data.stream.getAudioTracks().length > 0) {
        for (var i = 0; i < data.stream.getAudioTracks().length; i++) {
            if (data.mute) {
                if (data.stream.getAudioTracks()[i].enabled === true) {
                    console.info('MuteStream exec mute audio');
                    data.stream.getAudioTracks()[i].enabled = false;
                    This.isMute = true;
                }
            } else {
                if (data.stream.getAudioTracks()[i].enabled === false) {
                    console.info('MuteStream exec unmute audio');
                    data.stream.getAudioTracks()[i].enabled = true;
                    This.isMute = false;
                }
            }
        }
    } else if ((data.type === 'video' || data.type === 'slides') && data.stream.getVideoTracks().length > 0) {
        for (var j = 0; j < data.stream.getVideoTracks().length; j++) {
            if (data.mute) {
                if (data.stream.getVideoTracks()[j].enabled === true) {
                    console.info('MuteStream exec mute video/slides');
                    data.stream.getVideoTracks()[j].enabled = false;
                }
            } else {
                if (data.stream.getVideoTracks()[j].enabled === false) {
                    console.info('MuteStream exec unmute video/slides');
                    data.stream.getVideoTracks()[j].enabled = true;
                }
            }
        }
    }

    data && data.callback({ stream: data.stream });
};

Record.prototype.setConstraintsOfGetStream = function (data, constraints) {
    console.info("set Constraints of Get Stream");
    var This = this;
    var setConstraints = {};
    switch (data.streamType) {
        case 'audio':
            setConstraints = data.constraints;
            break;
        case 'video':
            if (!data.action) {
                console.info('get stream constraints: ' + JSON.stringify(constraints, null, '   '));
                setConstraints = {
                    audio: data.constraints.audio ? data.constraints.audio.deviceId ? { deviceId: { exact: data.constraints.audio.deviceId } } : data.constraints.audio : data.constraints.audio,
                    video: {
                        width: { ideal: constraints.video.width.exact },
                        height: { ideal: constraints.video.height.exact }
                        // frameRate: {exact: constraints.video.frameRate && constraints.video.frameRate.exact || ' '},
                        // deviceId: {exact: constraints.video.deviceId && constraints.video.deviceId.exact || ' '}
                    }
                };
            } else if (data.action === 'adjustResolution') {
                console.info('adjustResolution get stream constraints: ' + JSON.stringify(constraints, null, '   '));
                setConstraints = {
                    video: {
                        width: { exact: constraints.video.width.exact },
                        height: { exact: constraints.video.height.exact },
                        frameRate: { exact: constraints.video.frameRate && constraints.video.frameRate.exact || ' ' },
                        deviceId: { exact: constraints.video.deviceId.exact }
                    }
                };
                if (Number(constraints.video.width.exact) === 640 && Number(constraints.video.height.exact) === 360) {
                    delete setConstraints.video.height.exact;
                    setConstraints.video.height.ideal = constraints.video.height.exact;
                }
            } else if (data.action === 'switchLocalVideoDevice') {
                console.info('switch Local video Device get stream constraints: ' + JSON.stringify(constraints, null, '   '));
                if (Number(constraints.video.width.exact) === 1920) {
                    constraints.video.width.exact = 1280;
                    constraints.video.height.exact = 720;
                } else if (Number(constraints.video.width.exact) === 1280) {
                    constraints.video.width.exact = 640;
                    constraints.video.height.exact = 360;
                } else if (Number(constraints.video.width.exact) === 640) {
                    constraints.video.width.ideal = constraints.video.width.exact;
                    constraints.video.height.ideal = constraints.video.height.exact;
                    delete constraints.video.width.exact;
                    delete constraints.video.height.exact;
                } else {
                    console.warn(" The constraints parameter is not satisfied ");
                    data.callback({ error: data.error });
                }
                setConstraints = constraints;
            }
            if (This.getBrowserDetail().browser === 'firefox') {
                delete setConstraints.video.frameRate;
            }
            break;
        case 'screenShare':
            constraints = This.getScreenShareConstraints(data);
            break;
        default:
            console.warn('unknown type ' + data.streamType);
            break;
    }
    return setConstraints;
};

Record.prototype.closeStream = function (stream) {
    var This = this;
    if (!stream) {
        console.info('closeStream:stream is null');
        return;
    } else {
        console.info('close stream id: ' + stream.id);
    }

    try {
        Object.keys(This.localStreams).forEach(function (key) {
            var getStream = localStreams[key];
            if (getStream) {
                if (stream.id === getStream.id) {
                    This.localStreams[key] = null;
                }
            }
        });
        stream.oninactive = null;
        var tracks = stream.getTracks();
        for (var track in tracks) {
            tracks[track].onended = null;
            console.info('close stream');
            tracks[track].stop();
        }
    } catch (error) {
        console.info('closeStream: Failed to close stream');
        console.info(error);
    }
    stream = null;
};

/***
 * get file url
 * @param file
 * @returns {*}
 */
Record.prototype.getObjectURL = function (file) {
    var url = null;
    if (window.createObjectURL !== undefined) {
        // basic
        url = window.createObjectURL(file);
    } else if (window.URL !== undefined) {
        // mozilla(firefox)
        url = window.URL.createObjectURL(file);
    } else if (window.webkitURL !== undefined) {
        // webkit or chrome
        url = window.webkitURL.createObjectURL(file);
    }
    return url;
};
;(function ($) {

    $.fn.frameSelection = function (options) {
        var defaultOpts = {
            callback: function callback() {},
            mask: false,
            done: function done(result) {
                console.log(result);
            }
        };
        var options = $.extend({}, defaultOpts, options);
        new FrameSelection($(this), options);
    };
    /**
     * 坐标点
     * @param {*} x
     * @param {*} y
     */
    function Point(x, y) {
        this.x = x;
        this.y = y;
    }
    /**
     * 框选构造函数
     * @param {*} $rangeEl 容器元素
     * @param {*} options 选择项
     */
    function FrameSelection($rangeEl, options) {
        this.$rangeEl = $rangeEl;
        this.options = options;

        this.init();
    }
    /**
     * 框选初始化
     */
    FrameSelection.prototype.init = function () {
        this.unbind();
        this.bind();
    };
    /**
     * 解除事件绑定
     */
    FrameSelection.prototype.unbind = function () {

        this.$rangeEl.off('mousedown');
        this.$rangeEl.off('mousemove');
        this.$rangeEl.off('mouseup');
    };
    /**
     * 绘制接口
     */
    FrameSelection.prototype.render = function (p1, p2) {
        this.options.mask && this.renderMask(p1, p2);
        this.renderRect(p1, p2);
    };
    /**
     * 清理元素
     */
    FrameSelection.prototype.clear = function () {
        this.$rangeEl.find('.rect,.mask').remove();
    };

    /**
     * 创建
     *
     */
    FrameSelection.prototype.renderMask = function (p1, p2) {
        var $rect = this.$rangeEl.find('div.rect');
        // var shareVideo = document.getElementsByClassName("container_middle")[0]
        // var container = document.getElementById("container")
        // window.rectWidth = $rect.outerWidth();
        // window.rectHeight = $rect.outerHeight();
        // var $top = this.$rangeEl.find('div.mask:eq(0)'),
        //     $left = this.$rangeEl.find('div.mask:eq(1)'),
        //     $right = this.$rangeEl.find('div.mask:eq(2)'),
        //     $bottom = this.$rangeEl.find('div.mask:eq(3)');
        //
        //
        //
        // $top.css({
        //     // top: this.$rangeEl.css('top'),
        //     // left: this.$rangeEl.css('left') ,
        //     // width: this.$rangeEl.width(),
        //     // height:this.$rangeEl.height(),
        //     top: shareVideo.offsetTop,
        //     left: shareVideo.offsetLeft ,
        //     width: this.$rangeEl.width(),
        //     height:  window.tops
        //
        // });
        // // window.containerTop = this.$rangeEl.left();
        // // window.containerLeft = this.$rangeEl.top();
        // window.containerWidth = this.$rangeEl.width();
        // window.containerHeight = this.$rangeEl.height();
        // $left.css({
        //     // top: $rect.css('top'),
        //     top: $top.height()  ,
        //     left:  window.lefts - shareVideo.offsetLeft - container.offsetLeft,
        //     width: $rect.css('left'),
        //     // width: window.startPositionX- window.startLeftX,
        //     height: $rect.height()
        // });
        //
        // $right.css({
        //     top: $top.height() + shareVideo.offsetTop,
        //     left:  window.mouseDownLeft + $rect.width(),
        //     width: this.$rangeEl.width() - ($left.width() + $rect.width()),
        //     height: $left.height()
        // });
        //
        // $bottom.css({
        //     // top: $top.height() + $left.height(),
        //     // left: this.$rangeEl.css('left'),
        //     top: $top.height() + $left.height() + shareVideo.offsetTop,
        //     left:this.$rangeEl.css('left'),
        //     width: $top.width(),
        //     height: this.$rangeEl.height() - ($top.height() + $left.height())
        // });
    };

    /**
     * 创建矩形选框
     */
    FrameSelection.prototype.renderRect = function (p1, p2) {
        var $rect = this.$rangeEl.find('div.rect');
        var container = document.getElementById("container");

        $rect.css({
            top: Math.min(p1.y, p2.y) - container.offsetTop,
            left: Math.min(p1.x, p2.x) - container.offsetLeft,
            width: Math.abs(p1.x - p2.x),
            height: Math.abs(p1.y - p2.y)
        });
    };

    /**
     * 创建元素
     */
    FrameSelection.prototype.create = function (eleDes, n, callback) {
        var desArr = eleDes.split('.');
        var eleName = desArr[0],
            className = desArr[1] || '',
            eles = '';

        for (var i = 0; i < n; i++) {
            eles += '<' + eleName + ' class="' + className + '"></' + eleName + '>';
        }
        callback && typeof callback === "function" && callback($(eles));
    };
    FrameSelection.prototype.createElToDom = function () {
        var _this = this;

        //默认不绘制mask
        var fn = function fn($eles) {
            $eles.appendTo(_this.$rangeEl);
        };
        this.options.mask && this.create('div.mask', 4, fn);
        this.create('div.rect', 1, fn);

        typeof this.options.callback === 'function' && this.options.callback();
    };

    /**
     * 注册事件绑定
     */
    FrameSelection.prototype.bind = function () {
        var self = this;
        var container = document.getElementById("container");
        var shareVideo = document.getElementsByClassName("shareVideo")[0];

        this.$rangeEl.bind('mousedown', function (event) {
            if (window.record.currentRecoderType !== 'areaVideo') {
                console.warn("current recoderType is not areaVvideo");
                return;
            }
            if (window.record.isUploadVideo) {
                console.warn("上传视频文件");
                shareVideo = document.getElementsByClassName("shareLocalVideo")[0];
            }

            event.preventDefault();

            window.startPositionX = event.pageX - container.offsetLeft - shareVideo.offsetLeft;
            window.startPositionY = event.pageY - container.offsetTop - shareVideo.offsetTop;
            window.lefts = event.offsetX;
            window.tops = event.offsetY;
            window.mouseDownLeft = event.clientX;
            window.mouseDownTop = event.clientY;

            var start = new Point(event.pageX, event.pageY);

            //清理
            self.clear();
            self.createElToDom();

            self.$rangeEl.bind('mousemove', function (e) {
                var end = new Point(e.pageX, e.pageY);

                //绘制
                self.render(start, end);
            });
        });

        this.$rangeEl.bind('mouseup', function (e) {
            if (window.record.isUploadVideo) {
                console.warn("上传视频文件...");
                shareVideo = document.getElementsByClassName("shareLocalVideo")[0];
            }

            window.endPositionX = e.pageX - container.offsetLeft - shareVideo.offsetLeft;
            window.endPositionY = e.pageY - container.offsetTop - shareVideo.offsetTop;

            window.endLeft = e.offsetX;
            window.endTop = e.offsetY;

            finish();
            self.$rangeEl.off('mousemove');
        });
    };
})(window.jQuery);